# 观察者模式概述

观察者模式是使用`频率最高`的设计模式之一，它用于`建立一种对象与对象之间的依赖关系`，`一个对象发生改变时将自动通知其他对象`，其他对象将相应作出反应。在观察者模式中，
发生改变的对象称为`观察目标【红绿灯的变化】`，而被通知的对象称为`观察者【汽车】`，·`一个观察目标可以对应多个观察者【一个红绿灯可以对应多个汽车的走停】`，

而且这些观察者之间可以`没有任何相互联系`，可以根据需要·`增加和删除观察者`，使得系统更易于扩展。

---
## 观察者模式定义
观察者模式(Observer Pattern)：定义对象之间的·一种`一对多依赖`关系，使得每当一个对象状态发生改变时，`其相关依赖对象皆得到通知并被自动更新`。观察者模式的
别名包括`发布-订阅`模式、`模型-视图`（Model/View）模式、`源-监听器`模式或`从属者`模式。
观察者模式是一种对象行为型模式。

---
## 观察者结构模式图
观察者模式结构中通常包括观察目标和观察者·`两个继承层次`结构:
![img.png](观察者结构模式图.png)


在观察者模式结构图中包含如下几个角色：

● Subject`（目标）【红绿灯】`：
    目标又称为主题，它是指·`被观察的对象`。在目标中定义了一个`观察者集合`，一个观察目标可以接受`任意数量`的观察者来观察，它提供一系列方法来增加和删除观察者对象，
    同时它定义了通知方法notify()。目标类可以是`接口`，也可以是`抽象类`或`具体类`。

● ConcreteSubject`（具体目标）`：
    具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。
    如果无须扩展目标类，则具体目标类可以省略。

● Observer`（观察者）【汽车】`：
    观察者将对观察目标的改变做出反应，观察者一般定义为`接口`，该接口声明了更新数据的方法`update()`，因此又称为`抽象观察者`。

● ConcreteObserver`（具体观察者）`：
    在具体观察者中`维护`一个指向`具体目标对象的引用`，它存储具体观察者的有关状态，`这些状态需要和具体目标的状态保持一致`；它`实现`了在抽象观察者Observer中定义的`update()`方法。
    通常在实现时，可以调用具体目标类的attach()方法将自己`添加`到目标类的集合中或通过detach()方法将自己从目标类的集合中`删除`。

---
观察者模式描述了a`如何建立`对象与对象之间的`依赖关系`，以及如何构造满足这种需求的系统。观察者模式包含观察目标和观察者`两类对象`，一个目标可以有任意数目的与之相依赖的观察者，
一旦观察目标的状态发生改变，所有的观察者都将得到通知。作为对这个通知的响应，每个观察者都将监视观察目标的状态以使其状态与目标状态同步，这种交互也称为`发布-订阅`。
观察目标是通知的发布者，它发出通知时并`不需要`知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。

---
## 抽象目标 Subject//信号灯
```java
import java.util.*;
abstract class Subject {
    //定义一个观察者集合用于存储所有观察者对象
protected ArrayList observers<Observer> = new ArrayList();
 
//注册方法，用于向观察者集合中增加一个观察者
	public void attach(Observer observer) {
    observers.add(observer);
}
 
    //注销方法，用于在观察者集合中删除一个观察者
	public void detach(Observer observer) {
    observers.remove(observer);
}
 
    //声明抽象通知方法
	public abstract void notify();
}
```

## 具体目标类 ConcreteSubject
```java
class ConcreteSubject extends Subject {
    //实现通知方法
	public void notify() {
        //遍历观察者集合，调用每一个观察者的响应方法
		for(Object obs:observers) {
			((Observer)obs).update();
		}
	}	
}
```

## 抽象观察者 Observer//汽车

抽象观察者角色一般定义为`一个接口`，`通常只声明一个update()方法`，为不同观察者的更新（响应）行为定义相同的接口，这个方法在其子类中实现，
不同的观察者具有不同的响应方法。抽象观察者Observer典型代码如下所示：

```java
interface Observer {
    //声明响应方法
	public void update();
}
```

## 具体观察者
在具体观察者ConcreteObserver中实现了update()方法，其典型代码如下所示：

```java
class ConcreteObserver implements Observer {
    //实现响应方法
	public void update() {
		//具体响应代码
	}
}
```

在有些更加复杂的情况下，具体观察者类ConcreteObserver的update()方法在执行时需要使用到具体目标类ConcreteSubject中的`状态（属性）`，
因此在ConcreteObserver与ConcreteSubject之间有时候还存在`关联或依赖关系`，在ConcreteObserver中定义一个ConcreteSubject`实例`，
通过`该实例获取存储在ConcreteSubject中的状态`。如果ConcreteObserver的update()方法不需要使用到ConcreteSubject中的状态属性，
则可以对观察者模式的标准结构进行简化，在具体观察者ConcreteObserver和具体目标ConcreteSubject之间无须维持对象引用。
如果在具体层具有关联关系，系统的扩展性将受到一定的影响，增加**新的具体目标类有时候需要修改原有观察者的代码**，在一定程度上违反了“开闭原则”，
但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响。











